package uk.co.nickthecoder.paratask

import uk.co.nickthecoder.paratask.parameters.*
import uk.co.nickthecoder.paratask.util.child
import uk.co.nickthecoder.paratask.util.homeDirectory
import java.io.File
import java.io.PrintStream

/**
 * Generates a bash script suitable for adding to /etc/bash_completion.d for a single task.
 * This is useful if you have a script or an alias which runs a single task or tool.
 *
 * See Gnu's documentation on how command completion works :
 * https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html
 */
class GenerateTaskCompletionTask : AbstractTask() {

    val taskStringP = StringParameter("taskString", required = true)

    val taskP = TaskParameter("task", taskFactory = RegisteredTaskFactory.instance, required = true)

    val taskOrTaskStringP = OneOfParameter("taskOrTaskString", value = taskStringP, choiceLabel = "Choose")
            .addChoices(taskStringP, taskP)


    val commandNameP = StringParameter("commandName", value = "paratask")
    val commandName by commandNameP

    val outputFileP = FileParameter("output", expectFile = true, mustExist = null,
            value = homeDirectory.child(".bash_completion.d"))

    override val taskD = TaskDescription("generateTaskCompletion")
            .addParameters(taskOrTaskStringP, taskStringP, taskP, commandNameP, outputFileP)

    lateinit var out: PrintStream

    init {
        commandNameP.listen {
            if (outputFileP.value != null) {
                if (outputFileP.value!!.isDirectory) {
                    outputFileP.value = File(outputFileP.value!!, commandNameP.value)
                } else {
                    outputFileP.value = File(outputFileP.value!!.parentFile, commandNameP.value)
                }
            }
        }
    }

    override fun run() {
        if (outputFileP.value == null) {
            out = System.out
        } else {
            out = PrintStream(outputFileP.value)
        }

        val task = if (taskOrTaskStringP.value == taskP) {
            taskP.value!!
        } else {
            TaskFactory.createTask(taskStringP.value)
        }

        try {
            out.println("# Generated by : paratask ${taskD.name} --taskStringP ${task.creationString()}--commandName ${commandName}")
            out.println("# Copy to /etc/bash_completion.d/$commandName for system wide tab-completion of paratask commands.")
            out.println()

            generateFileComplete(out, commandName)

            out.println("_${commandName}Complete()")
            out.println("{")
            out.println("    local taskName cur prev")
            out.println("    COMPREPLY=()")
            out.println("    _get_comp_words_by_ref cur prev\n")

            generateForTask(out, task, commandName)

            out.println("}\n")

            out.println("complete -F _${commandName}Complete $commandName")

        } finally {
            if (out != System.out) {
                out.close()
            }
        }
    }

    companion object {

        fun generateFileComplete(out: PrintStream, commandName: String) {
            out.println("_${commandName}FileComplete()")
            out.println("{")
            out.println("    complete -F _${commandName}Complete $commandName")
            out.println("    return 0")
            out.println("}\n")
        }

        fun generateForTask(out: PrintStream, task: Task, commandName: String) {

            val parameterNames = task.taskD.valueParameters().map { "--${it.name}" }
            val booleanParameters = booleanParameters(task)
            val boolWithoutValues = booleanParameters.filter { (_, p) -> !p.needsValue() }
            val boolWithValues = booleanParameters.filter { (_, p) -> p.needsValue() }
            val trueFalseValues = boolWithValues.filter { (_, p) -> p.required }
            val trueFalseNullValues = boolWithValues.filter { (_, p) -> !p.required }

            val choiceParameters = choiceParameters(task)
            val fileParameters = fileParameters(task)
            val directoryParameters = directoryParameters(task)

            val boolConditions = boolWithoutValues.map { (name, _) -> "&& [[ \"\${prev}\" != --$name ]] " }.joinToString(separator = "")

            var unnamedParameter = task.taskD.unnamedParameter
            if (unnamedParameter is MultipleParameter<*, *>) {
                unnamedParameter = unnamedParameter.factory()
            }

            out.println("    if [[ \"\$prev\" == --* ]] $boolConditions; then")

            if (choiceParameters.isNotEmpty() || fileParameters.isNotEmpty() || directoryParameters.isNotEmpty() || boolWithValues.isNotEmpty()) {
                out.println("    case \$prev in")
                if (trueFalseValues.isNotEmpty()) {
                    out.println("        ${trueFalseValues.map { "--" + it.first }.joinToString(separator = "|")})")
                    out.println("            COMPREPLY=( \$( compgen -W 'true false' -- \$cur) )")
                    out.println("            return 0")
                    out.println("            ;;")
                }
                if (trueFalseNullValues.isNotEmpty()) {
                    out.println("        ${trueFalseNullValues.map { "--" + it.first }.joinToString(separator = "|")})")
                    out.println("            COMPREPLY=( \$( compgen -W 'true false null' -- \$cur) )")
                    out.println("            return 0")
                    out.println("            ;;")
                }
                choiceParameters.forEach { (name, choiceParameter) ->
                    val choices = choiceParameter.choiceKeys().joinToString(separator = " ")
                    out.println("        --$name)")
                    out.println("            COMPREPLY=( \$( compgen -W '$choices' -- \$cur) )")
                    out.println("            return 0")
                    out.println("            ;;")
                }
                if (fileParameters.isNotEmpty()) {
                    out.println("        ${fileParameters.map { "--" + it.first }.joinToString(separator = "|")})")
                    out.println("            complete -F _${commandName}FileComplete -o default $commandName")
                    out.println("            return 124")
                    out.println("            ;;")
                }
                if (directoryParameters.isNotEmpty()) {
                    out.println("        ${directoryParameters.map { "--" + it.first }.joinToString(separator = "|")})")
                    out.println("            complete -F _${commandName}FileComplete -o dirnames $commandName")
                    out.println("            return 124")
                    out.println("            ;;")
                }
                out.println("    esac") // End Case parameter name
            } else {
                out.println("        # No choice or file parameters")
                out.println("        COMPREPLY=()")
            }
            out.println("    else")
            // The current argument is either a parameter name (such as "--file"), or it is a value for the "unnamed" parameter
            // if the task has an unnamed parameter.
            if (unnamedParameter is ChoiceParameter<*>) {
                val choices = unnamedParameter.choiceKeys().joinToString(separator = " ")
                out.println("        COMPREPLY=( \$( compgen -W '$parameterNames $choices' -- \$cur) )")
            } else if (unnamedParameter is BooleanParameter && unnamedParameter.needsValue()) {
                val choices = if (unnamedParameter.required) listOf("true", "false") else listOf("true", "false", "null")
                out.println("        COMPREPLY=( \$( compgen -W '$parameterNames $choices' -- \$cur) )")
            } else if (unnamedParameter is FileParameter) {
                // Hmm, I can't see a way to provide completions of parameter names AND filenames together, so instead,
                // prompt for parameter names if the current is empty or begins with "--", otherwise prompt for filenames.
                out.println("        if [ -z \"\$cur\" ] || [[ \"\$cur\" == --* ]] ; then")
                out.println("            COMPREPLY=( \$( compgen -W '${parameterNames.joinToString(separator = " ")}' -- \$cur) )")
                out.println("        else")
                if (unnamedParameter.expectFile == false) {
                    out.println("            complete -F _${commandName}FileComplete -o dirnames $commandName")
                } else {
                    out.println("            complete -F _${commandName}FileComplete -o default $commandName")
                }
                out.println("        fi")
            } else {
                out.println("        COMPREPLY=( \$( compgen -W '${parameterNames.joinToString(separator = " ")}' -- \$cur) )")
            }
            out.println("        return 0")
            out.println("    fi")

        }


        inline fun <reified T : Parameter> multipleParametersInners(task: Task): List<Pair<String, T>> {
            return task.taskD.valueParameters().filterIsInstance<MultipleParameter<*, *>>().filter { it.factory() is T }.map { Pair(it.name, it.factory() as T) }
        }

        fun choiceParameters(task: Task): List<Pair<String, ChoiceParameter<*>>> {
            return task.taskD.valueParameters().filterIsInstance<ChoiceParameter<*>>().map { Pair(it.name, it) } +
                    multipleParametersInners<ChoiceParameter<*>>(task)
        }

        fun allFileParameters(task: Task): List<Pair<String, FileParameter>> {
            return task.taskD.valueParameters().filterIsInstance<FileParameter>().map { Pair(it.name, it) } +
                    multipleParametersInners<FileParameter>(task)
        }

        fun fileParameters(task: Task): List<Pair<String, FileParameter>> {
            return allFileParameters(task).filter { it.second.expectFile != false }
        }

        fun directoryParameters(task: Task): List<Pair<String, FileParameter>> {
            return allFileParameters(task).filter { it.second.expectFile == false }
        }

        fun booleanParameters(task: Task): List<Pair<String, BooleanParameter>> {
            return task.taskD.valueParameters().filterIsInstance<BooleanParameter>().map { Pair(it.name, it) } +
                    multipleParametersInners<BooleanParameter>(task)
        }

    }
}


fun main(args: Array<String>) {
    val task = GenerateTaskCompletionTask()
    task.taskP.value = OpenProjectTask()
    task.taskOrTaskStringP.value = task.taskP
    task.commandNameP.value = "ptp"
    TaskParser(task).go(args, prompt = true)
}
